package main

import (
	"bytes"
	"flag"
	"fmt"
	"math/rand"
	"os"
	"text/template"
	"time"
	"unsafe"
)

const (
	VERSION = "1.0"
)

var (
	s = flag.String("s", "", "string to obfuscate")
	p = flag.String("p", "", "pkg name for the generated code")
)

var (
	tpl = `// CODE GENERATED BY mumbojumbo {{ .Version }} (https://github.com/jeromer/mumbojumbo) DO NOT EDIT !!!!
// The code below obfuscates the following string:
//
//		{{ .Source }}
//
// In case you are wondering storing the string in a comment will not be
// readable by searching for strings in your binary as comments are stripped out
// of the binary generated by go build

package {{ .Pkg }}

import (
	"unsafe"
)

const (
	EAX = uint8(unsafe.Sizeof(true))
)

func Get() string {

{{ .Obfuscated }}

	return string(str)
}
`
)

func main() {
	flag.Parse()

	if *s == "" {
		quit("no string provided")
	}

	if *p == "" {
		quit("no pkg provided")
	}

	fmt.Println(
		generateGoCode(
			tplData{
				Version:    VERSION,
				Source:     *s,
				Pkg:        *p,
				Obfuscated: obfuscate(*s),
			},
		),
	)
}

// ----

type tplData struct {
	Version    string
	Source     string
	Pkg        string
	Obfuscated string
}

func generateGoCode(data tplData) string {
	tmpl := template.Must(
		template.New("x").Parse(tpl),
	)

	w := new(bytes.Buffer)
	err := tmpl.Execute(w, data)

	if err != nil {
		panic(err)
	}

	return w.String()
}

// ----

// shamefully taken from
// https://github.com/GH0st3rs/obfus/blob/master/obfus.go

const (
	EAX = uint8(unsafe.Sizeof(true))
	ONE = "EAX"
)

func obfuscate(txt string) string {
	b := []byte(txt)

	tmp := "var str []byte\n"

	for _, item := range b {
		tmp = fmt.Sprintf(
			"%s\nstr = append(str, %s)",
			tmp, getNumber(item),
		)
	}

	return tmp
}

func getNumber(n byte) (buf string) {
	var arr []byte

	for n > EAX {
		if n%2 == EAX {
			arr = append(arr, EAX)
		} else {
			arr = append(arr, 0)
		}
		n = n >> EAX
	}

	buf = ONE

	rand.Seed(
		time.Now().Unix(),
	)

	for i := len(arr) - 1; i >= 0; i-- {
		buf = fmt.Sprintf(
			"%s<<%s", buf, ONE,
		)

		if arr[i] == EAX {
			if rand.Intn(2) == 0 {
				buf = fmt.Sprintf(
					"(%s^%s)", buf, ONE,
				)
			} else {
				buf = fmt.Sprintf(
					"(%s|%s)", buf, ONE,
				)
			}
		}
	}

	return buf
}

func quit(msg string) {
	fmt.Println(msg)
	os.Exit(1)
}
