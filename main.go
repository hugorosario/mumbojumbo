package main

import (
	"bytes"
	"flag"
	"fmt"
	"math/rand"
	"os"
	"strings"
	"text/template"
	"time"
	"unsafe"
)

const (
	version = "1.2"
)

var (
	s  = flag.String("s", "", "string to obfuscate")
	p  = flag.String("p", "main", "pkg name for the generated code")
	op = flag.String("op", "eax()", "operation name for the generated code")
	f  = flag.String("f", "Get()", "getter function name for the generated code")
)

var (
	tpl = `// CODE GENERATED BY mumbojumbo {{ .Version }} (https://github.com/hugorosario/mumbojumbo) DO NOT EDIT !!!!

package {{ .Pkg }}

import (
	"unsafe"
)

func {{.OperationFunctionName}} uint8{
	return uint8(unsafe.Sizeof(true))
}

//{{.GetterFunctionName}} getter function
func {{.GetterFunctionName}}() string {
{{ .Obfuscated }}
}
`
)

func main() {
	flag.Parse()

	if *s == "" {
		quit("no string provided")
	}

	if *p == "" {
		quit("no pkg provided")
	}

	if !strings.HasSuffix(*op, "()") {
		*op = fmt.Sprintf("%s()", *op)
	}
	if strings.Contains(*f, "()") {
		*f = strings.ReplaceAll(*f, "()", "")
	}

	fmt.Println(
		generateGoCode(
			tplData{
				Version:               version,
				Pkg:                   *p,
				OperationFunctionName: *op,
				GetterFunctionName:    *f,
				Obfuscated:            obfuscate(*s, *op),
			},
		),
	)
}

// ----

type tplData struct {
	Version               string
	Pkg                   string
	OperationFunctionName string
	GetterFunctionName    string
	Obfuscated            string
}

func generateGoCode(data tplData) string {
	tmpl := template.Must(
		template.New("x").Parse(tpl),
	)

	w := new(bytes.Buffer)
	err := tmpl.Execute(w, data)

	if err != nil {
		panic(err)
	}

	return w.String()
}

// ----

// shamefully taken from
// https://github.com/GH0st3rs/obfus/blob/master/obfus.go

const (
	operator = uint8(unsafe.Sizeof(true))
)

func obfuscate(txt string, operationFunctionName string) string {
	lines := []string{}

	for _, item := range []byte(txt) {
		lines = append(
			lines, getNumber(item, operationFunctionName),
		)
	}

	return fmt.Sprintf(
		"return string(\n[]byte{\n%s,\n},\n)",
		strings.Join(lines, ",\n"),
	)
}

func getNumber(n byte, functionName string) (buf string) {
	var arr []byte
	var x uint8

	for n > operator {
		x = 0

		if n%2 == operator {
			x = operator
		}

		arr = append(arr, x)

		n = n >> operator
	}

	buf = functionName

	rand.Seed(
		time.Now().Unix(),
	)

	for i := len(arr) - 1; i >= 0; i-- {
		buf = fmt.Sprintf(
			"%s<<%s", buf, functionName,
		)

		if arr[i] == operator {
			op := "(%s|%s)"

			if rand.Intn(2) == 0 {
				op = "(%s^%s)"
			}

			buf = fmt.Sprintf(
				op, buf, functionName,
			)
		}
	}

	return buf
}

func quit(msg string) {
	fmt.Println(msg)
	os.Exit(1)
}
